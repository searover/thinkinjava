# thinkinjava
Exercises from the book "**Think in Java**"

1, Java SE5 引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。

2，无穷循环的第二种形式是for(;;)，编译器将while(true)和for(;;)看作是同一回事，所以具体选用哪个取决于自己的编程习惯。

3，编程语言中一开始就有goto关键词了。事实上，goto起源于汇编语言的程序控制，如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含很多跳转。（Java编译器生成它自己的“汇编代码”，但是这个代码是运行在Java虚拟机上的，而不是直接运行在CPU硬件上）。

4，需要记住的重点是：在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

5，关于Java构造器：尽管可以用this调用一个构造器，但不能调用两次，此外，必须将构造器调用置于最起始处，否则编译器会报错，另外，除了构造器外，编译器禁止在其他任何方法中调用构造器。

6，在static方法内部并不是不可调用非静态方法，如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用，你就可以调用非静态方法和访问非静态数据。

7，清理，垃圾回收：假定你的对象（并非使用new）获得一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。它的工作原理假定是这样的：一旦一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。

8，之所以要有finalize()方法，是由于分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言写的代码。在非Java代码中，也许会调用C的malloc()函数系列来分配内存，而且除非用了free()函数，否则存储空间将得不到释放，从而造成内存泄露。当然，free()是C和C++中的函数，所以需要在finalize()中用本地方法调用它。


9，不要过多的使用finalize()方法，它无法预料，常常是危险的，它确实不是进行普通的清理工作的合适场所。无论是垃圾回收，还是“终结finalize”，都不保证一定会发生。如果Java虚拟机并未面临耗尽内存的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

10，在以前用过的程序语言中，在堆上分配对象的代价十分昂贵，因此读者自然会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪-- 存储空间的释放竟然会影响存储空间的分配，但这确实是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。

11，在某些Java虚拟机中，堆的实现更像一个传送带，每分配一个对象，它就往前移动一格。这意味着对象的存储空间的分配非常快。Java的“堆”指针只是简单的移动到尚未分配的区域，其效率比得上C++在堆栈上分配空间的效率。但Java的堆未必完全像传送带那样工作，要真是那样的话，会导致频繁的内存页面调度--将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能，最终，在创建了足够多的对象之后，内存资源将耗尽。其中的秘密就在于垃圾回收器的介入。当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易的移动到更靠近传送带开始的地方，也就尽量避免了页面错误，通过垃圾回收器对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。

12，Java尽力保证：所有变量在使用前都能得到恰当的初始化，对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。要是类的灵气成员（即字段）是基本类型，情况就会变得有些不同，类的每个基本类型数据成员保证都会有一个初始值。

13，总结一下对象创建的过程，假设有个名为Dog的类：
    1，即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，或者Dog的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
    2，然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
    3，当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
    4，这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，而引用则被设置成了null。
    5，执行所有出现于字段定义处的初始化动作。
    6，执行构造器，这可能会牵涉到很多动作，尤其是涉及继承的时候。
 
14，实例初始化子句与静态初始化子句一模一样，只不过少了static关键字。这种语法对于支持“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式的构造器，某些操作都会发生。

15，所有数组（无论它们的元素是对象还是基本类型）都有一个固有成员，可以通过它获知数组内包含多少个元素，但不能对其修改，这个成员就是length。

16，class [I 前导的"["表示这是一个后面紧随的类型的数组，而紧随的“I”表示基本类型int

17，你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不用它。

18，在Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果在一个名字中有多个单词，用下划线将他们隔开）。

19，Java的垃圾回收器极大的简化了编程工作，而且在处理内存方面也更安全。然而，垃圾回收器确实也增加了运行时的开销，而且Java解释器从来就很慢，所以这种开销到底造成多大的影响也很难看出。随着时间的推移，Java在性能方面已经取得长足进步，但在速度总是上仍然是它涉足某些特定编程领域的障碍。

20，访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限（没有关键词）和private。

21，当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每一个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每一个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。

22，Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。

23，Java解释器的运行过程如下：首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称，并将每个句点换成反斜杠，以从CLASSPATH根中产生一个路径名称。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件（解释器还会去查找某些涉及Java解释器所在位置的标准目录）。

24，对使用Java的新手来说，设置CLASSPATH是很麻烦的一件事，为些，Sun将Java2中的JDK改造得更聪明了一些。在安装后你会发现，即使你未设立CLASSPATH，你也可以编译并运行基本的Java程序。

25，提供访问器（accessor）和变异器（mutator）方法（也称作get/set方法），以读取和改变数值。正如在第22章中看到的，对OOP而言，这是最优雅的方式，而且这也是JavaBean的基本原理。

26，不要错误的认为Java总是将当前目录视作查找行为的起点之一，如果你的CLASSPATH之中缺少一个“.”作为路径之一的话，Java就不会查找那里。

27，如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员，当然，如果在同一包中继承类，就可以操纵所有的拥有包访问权限的成员。

28，注意，类既不可以是private的（这样会使得除该类之外，其他任何类都不可以访问它），也不可以是protected的（事实上，一个内部类可以是private或者protected的），对于类的访问权限，仅有两个选择，public或包访问权限。

29，相同目录下的所有不具有明确package声明的文件，都被视作是该目录下默认包的一部分。

30，为了继承，一般的规则是将所有数据成员都指定为private，将所有方法指定为public。

31，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表。
