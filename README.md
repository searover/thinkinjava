# thinkinjava
Exercises from the book "**Think in Java**"

1, Java SE5 引入了一种新的更加简洁的for语法用于数组和容器，即foreach语法，表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项 。

2，无穷循环的第二种形式是for(;;)，编译器将while(true)和for(;;)看作是同一回事，所以具体选用哪个取决于自己的编程习惯。

3，编程语言中一开始就有goto关键词了。事实上，goto起源于汇编语言的程序控制，如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含很多跳转。（Java编译器生成它自己的“汇编代码”，但是这个代码是运行在Java虚拟机上的，而不是直接运行在CPU硬件上）。

4，需要记住的重点是：在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

5，关于Java构造器：尽管可以用this调用一个构造器，但不能调用两次，此外，必须将构造器调用置于最起始处，否则编译器会报错，另外，除了构造器外，编译器禁止在其他任何方法中调用构造器。

6，在static方法内部并不是不可调用非静态方法，如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用，你就可以调用非静态方法和访问非静态数据。

7，清理，垃圾回收：假定你的对象（并非使用new）获得一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。它的工作原理假定是这样的：一旦一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。

8，之所以要有finalize()方法，是由于分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是在Java中调用非Java代码的方式。本地方法目前只支持C和C++，但它们可以调用其他语言写的代码。在非Java代码中，也许会调用C的malloc()函数系列来分配内存，而且除非用了free()函数，否则存储空间将得不到释放，从而造成内存泄露。当然，free()是C和C++中的函数，所以需要在finalize()中用本地方法调用它。


9，不要过多的使用finalize()方法，它无法预料，常常是危险的，它确实不是进行普通的清理工作的合适场所。无论是垃圾回收，还是“终结finalize”，都不保证一定会发生。如果Java虚拟机并未面临耗尽内存的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

10，在以前用过的程序语言中，在堆上分配对象的代价十分昂贵，因此读者自然会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪-- 存储空间的释放竟然会影响存储空间的分配，但这确实是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。

11，在某些Java虚拟机中，堆的实现更像一个传送带，每分配一个对象，它就往前移动一格。这意味着对象的存储空间的分配非常快。Java的“堆”指针只是简单的移动到尚未分配的区域，其效率比得上C++在堆栈上分配空间的效率。但Java的堆未必完全像传送带那样工作，要真是那样的话，会导致频繁的内存页面调度--将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能，最终，在创建了足够多的对象之后，内存资源将耗尽。其中的秘密就在于垃圾回收器的介入。当它工作时，将一面回收空间，一面使堆中的对象紧凑排列，这样“堆指针”就可以很容易的移动到更靠近传送带开始的地方，也就尽量避免了页面错误，通过垃圾回收器对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。

12，Java尽力保证：所有变量在使用前都能得到恰当的初始化，对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。要是类的灵气成员（即字段）是基本类型，情况就会变得有些不同，类的每个基本类型数据成员保证都会有一个初始值。

13，总结一下对象创建的过程，假设有个名为Dog的类：
    1，即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，或者Dog的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
    2，然后载入Dog.class，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
    3，当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
    4，这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，而引用则被设置成了null。
    5，执行所有出现于字段定义处的初始化动作。
    6，执行构造器，这可能会牵涉到很多动作，尤其是涉及继承的时候。
 
14，实例初始化子句与静态初始化子句一模一样，只不过少了static关键字。这种语法对于支持“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显式的构造器，某些操作都会发生。

15，所有数组（无论它们的元素是对象还是基本类型）都有一个固有成员，可以通过它获知数组内包含多少个元素，但不能对其修改，这个成员就是length。

16，class [I 前导的"["表示这是一个后面紧随的类型的数组，而紧随的“I”表示基本类型int

17，你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不用它。

18，在Java SE5中添加了一个看似很小的特性，即enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便的处理。由于枚举类型的实例是常量，因此按照命名惯例它们都用大写字母表示（如果在一个名字中有多个单词，用下划线将他们隔开）。

19，Java的垃圾回收器极大的简化了编程工作，而且在处理内存方面也更安全。然而，垃圾回收器确实也增加了运行时的开销，而且Java解释器从来就很慢，所以这种开销到底造成多大的影响也很难看出。随着时间的推移，Java在性能方面已经取得长足进步，但在速度总是上仍然是它涉足某些特定编程领域的障碍。

20，访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限（没有关键词）和private。

21，当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每一个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每一个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。

22，Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。

23，Java解释器的运行过程如下：首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称，并将每个句点换成反斜杠，以从CLASSPATH根中产生一个路径名称。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件（解释器还会去查找某些涉及Java解释器所在位置的标准目录）。

24，对使用Java的新手来说，设置CLASSPATH是很麻烦的一件事，为些，Sun将Java2中的JDK改造得更聪明了一些。在安装后你会发现，即使你未设立CLASSPATH，你也可以编译并运行基本的Java程序。

25，提供访问器（accessor）和变异器（mutator）方法（也称作get/set方法），以读取和改变数值。正如在第22章中看到的，对OOP而言，这是最优雅的方式，而且这也是JavaBean的基本原理。

26，不要错误的认为Java总是将当前目录视作查找行为的起点之一，如果你的CLASSPATH之中缺少一个“.”作为路径之一的话，Java就不会查找那里。

27，如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员，当然，如果在同一包中继承类，就可以操纵所有的拥有包访问权限的成员。

28，注意，类既不可以是private的（这样会使得除该类之外，其他任何类都不可以访问它），也不可以是protected的（事实上，一个内部类可以是private或者protected的），对于类的访问权限，仅有两个选择，public或包访问权限。

29，相同目录下的所有不具有明确package声明的文件，都被视作是该目录下默认包的一部分。

30，为了继承，一般的规则是将所有数据成员都指定为private，将所有方法指定为public。

31，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表。

32, 到底是该用组合还是用继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基本类型向上转型。如果必须向上转型，则继承是必要的；但如果不需要，则应当好好考虑自己是滞需要继承。-p140

33，一个既是static又是final的域只占据一段不能改变的存储空间。-p140

34，
    public static final int VALUE = 20;
    是一种典型的对常量进行定义的方式，定义为public，则可以被用于包之外；定义为static，则强调只有一份；定义为final，则说明它是一个常量。

35，final参数，Java允许在参数列表中以声明的方式将参数指明为final。这意味着这意味着你无法在方法中更改参数引用所指向的对象。这一特性主要是向匿名内部类传递数据。-p143

36，Java中除了static方法和final方法之外，其他所有的方法都是后期绑定。

37，在一个设计良好的OOP程序中，大多数或者所有方法都遵循turn()的模型，而且只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出亲折数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。

38，多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。

39，编写构造器时有一条有效的准则：“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”。在构造器内唯一能够安全调用的那些方法是基类中的final方法（也适用于private方法，它们自动属于final方法）。这些方法不能被覆盖，因此也就不会出现上述令人惊讶的问题。 -p164

40，一条能用准则是：“用继承表达行为间的差异，并用字段表达状态上的变化”。在上述例子中，两者都用到了：通过继承得到了两个不同的类，用于表达act()方法的差异；而Stage通过运用组合使自己的状态发生变化。在这种情况下，这种状态的改变也就产生了行为的改变。 -p165

41, 像本例这样，创建一个能够根据所传递参数对象的不同而具有不同行为的方法，被称为策略模式。这类方法包含所有执行的算法中固定不变的部分，而“策略”包含变化的部分。-p175

42，放入接口的中域自动是static和final的。

43，想要直接创建内部类对象，你不能按你想像的方式，去引用外部类的名字，而是必须使用外部类的对象来创建该内部类对象。在拥有外部类对象之前，是不可能创建内部类对象的，这是因为内部类对象会暗暗地连接到创建它的外部类对象上，但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。

44，当内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便的隐藏实现细节。

45，任何抽象性都应该是应真正的需求而产生的。当必需时，你应该重构接口而不是到处添加额外的间接性，并由此带来额外的复杂性。这种额外的复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到由于以防万一而添加了新接口，而没有其他更有说服力的原因，那么好吧，如果我碰上这种事，就是质疑此人所作的所有设计。 -p189

46，恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必需性变得非常明确，那么就进行重构。接口是一种重要的工具，但是它们容易被滥用。 -p189

47，如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。

48，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和方法，也不能饮食嵌套类，但是嵌套类可以包含所有这些东西。

49，为什么需要内部类？
    一般来说，内部类继承自某个类或者实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。
    内部类必需要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：如果这能满足需求，那么就应该这么做！
    那么内部类实现一个接口与外围类实现这个接口有什么区别呢？答案是：后者不能总享用到接口带来的方便，有时需要用到接口的实现。
    所以，使用内部类最吸引人的原因是：每个内部类都能独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
    内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”，也就是说，内部类允许继承多个非接口类型。
    如果不需要解决“多重继承”的问题，那么自然可以用另的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：
        1）内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立。
        2）在单个外围类中，可以让多个内部类以不同的方式实现同一接口，或继承同一个类。
        3）创建内部类对象的时刻并不依赖于外围类对象的创建。
        4）内部类并没有令人迷惑的“is-a”的关系； 它就是一个独立的实体。举个例子，如果 Sequence.java不使用内部类，就必须声明“Sequence 是一个 Selector”，对于某个特定的Sequence只能有一个Selector。然而使用内部类很容易就能拥有另一个方法 reverseSelector()，用它来生成一个反向遍历序列的Selector。只有内部类才有这种灵活性。


